--- Solver.h.orig	2020-03-25 23:06:16.000000000 +0100
+++ Solver.h	2020-03-25 23:10:34.000000000 +0100
@@ -106,6 +106,25 @@
     Solver(const  Solver &s);
     
     virtual ~Solver();
+
+    void* termCallbackState;
+    int (*termCallback)(void* state);
+    void setTermCallback(void* state, int (*termCallback)(void*)) {
+       this->termCallbackState = state;
+       this->termCallback = termCallback;
+    }
+
+    void* learnCallbackState;
+    int* learnCallbackBuffer;
+    int learnCallbackLimit;
+    void (*learnCallback)(void * state, int * clause);
+    void setLearnCallback(void * state, int maxLength, void (*learn)(void * state, int * clause)) {
+      this->learnCallbackState = state;
+      this->learnCallbackLimit = maxLength;
+      this->learnCallbackBuffer = (int*) realloc (this->learnCallbackBuffer, (1+maxLength)*sizeof(int));
+      this->learnCallback = learn;
+    }
+
     
     /**
      * Clone function
@@ -545,7 +564,7 @@
 inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }
 inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }
 inline bool     Solver::withinBudget() const {
-    return !asynch_interrupt &&
+    return !asynch_interrupt && (termCallback == NULL || 0 == termCallback(termCallbackState)) &&
            (conflict_budget    < 0 || conflicts < (uint64_t)conflict_budget) &&
            (propagation_budget < 0 || propagations < (uint64_t)propagation_budget); }
 
